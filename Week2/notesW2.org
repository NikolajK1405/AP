#+title: Notes week 2 AP


* Functor
x :: Maybe Int
Returns Just int or Nothing
Good way to return something that indicates that the result could not be determined

Maybe is a functor, as such we can use fmap or (<$>) which is the same as fmap
(>= 18) <$> getAge name
Applies the function is x greater than 18 to the result of getAge name.

=> is a type constraint in a function, fx (Functor f, Ord a) =>

let can have multiple bindings to a single let keyword:
let
        x = ..
        y = ..
in ..

If u get a GHCi type error, remove the type annotation and call :t <func> to see haskells auto infered type


* Applicative functor
Functor with aditional stuff.
#+begin_src haskell
(<*>) :: f (a -> b) -> f a -> f b
pure :: a -> f a
#+end_src
For example, in the case we have something returning a Maybe function, that is the thing we return might be a Just f or Nothing. Here we can use the <*> operator to apply the function if possible, otherwise going to the default value.
So we can use a function within a functor, to apply it to a value in a functor, where the function only is applied to the value inside the functor.
Here is how it would look with maybe

,#+begin_src haskell
instance Applicative Maybe where
  pure x = Just x
  f <*> x = case f of
              Just f' ->
                case x of
                  Just x' -> Just (f' x')
                  Nothing -> Nothing
              Nothing -> Nothing

-- Or more simply:
instance Applicative Maybe where
  pure x = Just x
  Just f <*> Just x = Just (f x)
  _ <*> _ = Nothing
#+end_src

* Monads
Here we have a function that also might fail, f :: Int -> Maybe Int
If we use fmap we would get something like this:
fmap f (Maybe x) -> Maybe (f x) -> Maybe (Maybe x)

Instead we want something like this:
#+begin_src haskell
(>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
(>>=) Nothing _ = Nothing
(>>=) (Just x) f = f x
-- For example
x >>= f
#+end_src

So what happens here is that we take the check the value of Maybe x, evaluates if nothing or Just, if Just, we apply the pure (Maybe x -> x) value to the function.

It also works with fx Either, where Left err will be the "do nothing" case. Also linked lists if we want to apply a map, do nothing for the empty list.


Lingo for monads is as follows:
For a function f (a -> m b) where m is a monad, we say that the function returns a /command in the monad m which can produce a value of type b when executed/. In this case we call f a /monadic function/.

* Putting it together
So we have the methods:
#+begin_src haskell
-- Functor:
fmap :: (a -> b) -> f a -> f b
-- Applicative:
(<*>) :: f (a -> b) -> f a -> f b
pure :: a -> f a
-- Monad:
(>>=) :: m a -> (a -> m b) -> m b
#+end_src
We can use (>>=) and pure to express fmap and (<*>)
For example fmap:
#+begin_src haskell
liftM :: Monad m => (a -> b) -> m a -> m b
liftM f x = x >>= \x' -> pure (f x')
#+end_src
So here we use the bind operator to apply the pure x to an anonymus function. In here we apply x to f, and put it back into the monad with the pure function.

We can do the same for (<*>):
#+begin_src haskell
ap :: Monad m => m (a -> b) -> m a -> m b
ap f x = f >>= \f' ->
         x >>= \x' ->
           pure (f' x')
#+end_src
So here we use a bind operator on both arguments, "packing them out" of the monads. Then we apply the function, and wrap it back into the monad again.

* Do notation
We can use do notation to write nested bindings more nice:
#+begin_src haskell
-- This:
foo >>= (\x ->
bar >>= (\y ->
           baz x y))
-- Becomes this:
do x <- foo
   y <- bar
   baz x y

-- We can give more arguments (but be carefull about indentation!):
do x <- foo one_argument
          more arguments...
   y <- x
   ...

#+end_src
Every line in do corresponds to a monadic action


* Implementing Functor, Applicative and Monad
Make a setup like so:
#+begin_src haskell
newtype Reader env a = Reader (env -> a)
instance Functor (Reader env) where
  fmap = undefined

instance Applicative (Reader env) where
  (<*>) = undefined
  pure x = undefined

instance Monad (Reader env) where
  m >>= f = undefined
#+end_src
Start with implementing pure, be sure to see what u have and what u need. If u are confused about what a type of a variable in put and underscore and HCi will say "found a hole".
Next implement bind (>>=)
Do one step at a time, with undefined at the end and extend it slowly.
Try to unpack things we know the structure of, fx a monad. Functions cannot be unpacked.

It is possible to use the predefined functions ap and liftM, to define (<*>) and fmap. So all we need to define is pure and bind.

* Using monads
U always need an execution function for a monad, that returns the pure content.
The Reader monad has a context we can use to manipulate the result.
In a pure language like haskell which has imutable values another usefull monad is a State (s -> (a, s)), state has a function taking a state and returning a modfied state and the result of a function.
The interface for a state has a get function and a put function. Also a runState to unpack the monad.
get creates a State that places the given states as both return values
put creates a state from an initial state with no return value
