# GHCi
data keyword used to create a type:
data List 
    = Nil
    | Cons Int List

:info <data>
Tells info about data

Need to define the Show class for a new type, create a show function
instance Show List where
    show Nil = "Nil"
    show (Cons x xs) = "Cons(" ++ show x ++ " " ++ show xs ++ ")"

$ Nil
Nil

Alternativly do like this, to auto generate show
data List 
    = Nil
    | Cons Int List
    deriving (Show)

len :: List -> Int
len Nil = 0
len (Cons _x xs) = 1 + len xs
declaring _x means that we dont need to use the variable x

If we want the list to have more types than int, we do
#+begin_src haskell
data List a
    = Nil
    | Cons a (List a)
    deriving (Show)

:t provides the infered type
: is the cons operator: 1 : [] -> [1]
++ concats two lists: [1] ++ [2] -> [1,2]
#+end_src
type keyword creates a synonym for an existing type
type Mass = Double
type Velocity = Double
energy :: Mass -> Velocity -> Double
energy m v = 0.5 * m * (v * v)

Multi line comment
{-
-}

undefined keyword for type checking, see if some type is OK
tmp :: some type
tmp = undefined

We can define a unit type so we dont need to define a new function for each of the subtypes
data Q u = Q double
data Mass
data Velocity
someMass :: Q Mass
someMass = Q 123

If we want to avoid writing Q, except for in the type we need to convert it to a NUM
Create an instance and fill out all the necesarry functions for a number, +, - ect.

ghcup install dhc 9.8.4

# Lecture 4. sep - Type classes
Hoogle website, Haskell documentation
There are stated some laws that our data types should abide by
Look closely at the propperties the abstraction states and follow those
Take the types, methods and laws

data Pos1 = Pos1 Integer Integer
    deriving(Show)

-- Here we define the equality for the data type Pos1
instance Eq Pos1 where
    -- (==) :: Pos1 -> Pos1 -> Bool - we write this as a comment to know what we are working with
    Pos1 x1 y1  == Pos1 x2 y2 = undefined -- Put this in GHCi to see if it type checks
    Pos1 x1 y1  == Pos1 x2 y2 = x1 == x2 && y1 == y2

* Functor
A functor states that a type class is a container
data Box a = Box a
    deriving (Eq, Show)
#+begin_src haskell
instance Functor Box where
    -- fmap :: (a -> b) -> Box a -> Box b
    -- Need: b
    -- Have:
    -- f :: (a -> b)
    -- x :: a
    fmap f (Box x) = Box _
#+end_src
Approach when coding is to write what u have and what u need, that makes it clear we should do
Functor has the methods:
#+begin_src haskell
fmap :: (a -> b) -> f a -> f b

fmap f (Box x) = Box (f x)
#+end_src
Semigroup, combines to things, for example @ for list, or + to ints
Monoid is a sub type of semigroup containing a mempty :: a

So everything that is a monoid we can use the monoid functions for, fx mconcat :: [a] -> a

For example when making a homemade list data, we can make it into a monoid to automatically be able to use mconcat
